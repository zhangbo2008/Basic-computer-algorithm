##http://www.cnblogs.com/mycapple/archive/2012/08/09/2630430.html
'''下面我们继续搞树状数组,也就是数组树'''
'''传统数组(共n个元素)的元素修改和连续元素求和的复杂度分别为O(1)和O(n)。树状数组通过将线性结构转换成伪树状结构（线性结构只能逐个扫描元素，而树状结构可以实现跳跃
式扫描），使得修改和求和复杂度均为O(lgn)，大大提高了整体效率。'''
'''这个东西很神秘,数学上很深.
比如一个数组有8个元素记作a1,....a8
那么做一个新数组c,要求这个数组能加出a1到an的任何一个sum n从1到8
并且这个数组的生成最快,做的运算最少来得到这个数组c'''
'''这个数组是
c1=a1
c2=a1+a2
c3=a3
c4=a1+a2+a3+a4
c5=a5
c6=a5+a6
c7=a7
c8=a1+a2+a3+a4+a5+a6+a7+a8'''
'''对于这个c数组如何找到很神秘'''
'''https://www.cnblogs.com/hsd-/p/6139376.html'''
'''上面这个微博里面的图形很形象表现出来了,
我保存到了2.png'''#ps:从这里面说明我想做的ide带图片的多重要,不然神他妈能说清楚.
'''也就是上面这个链接从上往下数的第五个picture,说的很明白了,图里面你从上往下看,
看这个树,他的第一个元素就是c数组里面需要的元素.真心形象.也保证了这个树的每一个列都取
一个,因为 我们只取最北的那一个就行了'''
'''那么问题来了,改如何证明?感觉还是一个图论的问题,还是从树上入手
1.首先这种取法能保证任何a1加到an都能分解成c里面的和,这很显然,因为
从树这个图能看出来任何的求和,也就是最下面一排的取一个a1到am,都可以分解c里面的和'''
'''2.还需要证明这种c的算法最节约时间的,首先2分是显然的思路,3分或者更高显然速度慢,
所以我们只需要讨论图里面为什么c不选其他的点就行了.那么只需要讨论一个,比如c4就可以了
,我们假设c4不取到最北的点,比如c4取为他下面一个点也就是c4=a3+a4,
这样显然我们如果其他点都不变的话,a1,a1+a2,a1+a2+a3的计算次数
都没变化,但是a1+a2+a3+a4的计算次数多一次.
再看后面a1+a2+a3+a4+a5也是要多一次,归纳法显然后面的嘉禾都多一次,
所以时间复杂度加了O(N),所以变差了,再用归纳法对c4,c5...做归纳,就得到这种算法是最快
的结论,证毕.当然这只是一个初步证明,话说我就喜欢骗自己,当不会证明时候也非要写一种伪证明
来骗自己,否则不敢用.总怕有反例,然而骗自己证明了就随便用...总感觉不证明的东西,用起来
总保证不了是最好的算法,不够完美.'''
'''代码实现都是很多数学推导利用二进制来进行拆分,写了也记不住,只写到理解算法的层面了.'''


























